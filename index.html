<!DOCTYPE html>
<html lang="bn">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Memory Execution Visualizer - React</title>

  <!-- Tailwind CSS (CDN) -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- JetBrains Mono font (optional) -->
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600;700&display=swap" rel="stylesheet" />

  <style>
    :root { color-scheme: dark; }
    body { font-family: 'JetBrains Mono', ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
  </style>

  <!-- React & ReactDOM (UMD) -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

  <!-- Babel (to run JSX in browser) -->
  <script crossorigin src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body class="min-h-screen bg-black">
  <div id="root"></div>

  <!-- App Code -->
  <script type="text/babel">
    const { useEffect, useMemo, useRef, useState } = React;

    // ---------- Small helpers ----------
    function clsx(...xs) { return xs.filter(Boolean).join(" "); }

    function Card({ title, children, className }) {
      return (
        <div className={clsx("rounded-2xl shadow-md border border-white/10 bg-zinc-900/60", className)}>
          {title && (
            <div className="px-4 py-2 border-b border-white/10 text-sm font-semibold text-zinc-200">
              {title}
            </div>
          )}
          <div className="p-4">{children}</div>
        </div>
      );
    }

    function Pill({ children }) {
      return <span className="px-2 py-0.5 rounded-full bg-zinc-700/60 text-xs">{children}</span>;
    }

    // ---------- Address helpers ----------
    function toHex(n, pad = 8) { return "0x" + n.toString(16).padStart(pad, "0"); }

    const STACK_TOP = 0x7fffe000; // stack grows down
    const HEAP_BASE = 0x10000000; // heap grows up

    // ---------- Scenario 1: Pointers & malloc/free ----------
    const codePointers = `#include <stdio.h>
#include <stdlib.h>

int main() {
    int x = 42;           // [1]
    int *p = &x;          // [2]
    *p = 50;              // [3]
    int *q = (int*)malloc(sizeof(int)); // [4]
    *q = 99;              // [5]
    free(q);              // [6]
    return 0;             // [7]
}`;

    function scriptPointers() {
      const addrX = toHex(STACK_TOP - 0x20);
      const addrP = toHex(STACK_TOP - 0x24);
      const addrQ = toHex(STACK_TOP - 0x28);
      const heapInt = HEAP_BASE;

      const steps = [
        {
          lines: [5],
          desc: "প্রোগ্রাম শুরু: main() স্ট্যাক ফ্রেম তৈরি হয়েছে",
          stack: [ { name: "main", locals: [], retAddr: toHex(0x401000) } ],
          heap: [],
          stdout: ""
        },
        {
          lines: [6],
          desc: "int x = 42; → স্ট্যাকে x এর জন্য 4 বাইট বরাদ্দ ও মান 42",
          stack: [ {
            name: "main",
            locals: [ { name: "x", type: "int", addr: addrX, size: 4, value: 42 } ],
          }],
          heap: [],
          stdout: ""
        },
        {
          lines: [7],
          desc: "int *p = &x; → p তে x-এর ঠিকানা রাখা হলো",
          stack: [ {
            name: "main",
            locals: [
              { name: "x", type: "int", addr: addrX, size: 4, value: 42 },
              { name: "p", type: "int*", addr: addrP, size: 8, value: addrX },
            ],
          }],
          heap: [],
          stdout: ""
        },
        {
          lines: [8],
          desc: "*p = 50; → p যে ঠিকানায় ইঙ্গিত করছে (x), সেখানে 50 লেখা হলো",
          stack: [ {
            name: "main",
            locals: [
              { name: "x", type: "int", addr: addrX, size: 4, value: 50 },
              { name: "p", type: "int*", addr: addrP, size: 8, value: addrX },
            ],
          }],
          heap: [],
          stdout: ""
        },
        {
          lines: [9],
          desc: "int *q = (int*)malloc(sizeof(int)); → হিপে 4 বাইট বরাদ্দ, q তে তার ঠিকানা",
          stack: [ {
            name: "main",
            locals: [
              { name: "x", type: "int", addr: addrX, size: 4, value: 50 },
              { name: "p", type: "int*", addr: addrP, size: 8, value: addrX },
              { name: "q", type: "int*", addr: addrQ, size: 8, value: toHex(heapInt) },
            ],
          }],
          heap: [ {
            addr: toHex(heapInt), size: 4, bytes: [0,0,0,0], label: "malloc(int)"
          }],
          stdout: ""
        },
        {
          lines: [10],
          desc: "*q = 99; → হিপের নতুন ব্লকে 99 লেখা হলো",
          stack: [ {
            name: "main",
            locals: [
              { name: "x", type: "int", addr: addrX, size: 4, value: 50 },
              { name: "p", type: "int*", addr: addrP, size: 8, value: addrX },
              { name: "q", type: "int*", addr: addrQ, size: 8, value: toHex(heapInt) },
            ],
          }],
          heap: [ {
            addr: toHex(heapInt), size: 4, bytes: [99,0,0,0], label: "malloc(int)"
          }],
          stdout: ""
        },
        {
          lines: [11],
          desc: "free(q); → হিপ ব্লক মুক্ত, q এর মান অপরিবর্তিত (dangling pointer hazard)",
          stack: [ {
            name: "main",
            locals: [
              { name: "x", type: "int", addr: addrX, size: 4, value: 50 },
              { name: "p", type: "int*", addr: addrP, size: 8, value: addrX },
              { name: "q", type: "int*", addr: addrQ, size: 8, value: toHex(heapInt) },
            ],
          }],
          heap: [ {
            addr: toHex(heapInt), size: 4, bytes: [null,null,null,null], freed: true, label: "freed"
          }],
          stdout: ""
        },
        {
          lines: [12],
          desc: "return 0; → main ফ্রেম ধ্বংস হবে, প্রোগ্রাম শেষ",
          stack: [ {
            name: "main",
            locals: [
              { name: "x", type: "int", addr: addrX, size: 4, value: 50 },
              { name: "p", type: "int*", addr: addrP, size: 8, value: addrX },
              { name: "q", type: "int*", addr: addrQ, size: 8, value: toHex(heapInt) },
            ],
          }],
          heap: [ { addr: toHex(heapInt), size: 4, bytes: [null,null,null,null], freed: true, label: "freed" } ],
          stdout: ""
        },
      ];
      return steps;
    }

    // ---------- Scenario 2: Functions & Recursion (factorial) ----------
    const codeRecursion = `#include <stdio.h>

int fact(int n) {
    if (n <= 1) return 1;  // [1]
    return n * fact(n - 1); // [2]
}

int main() {
    int r = fact(3);        // [3]
    printf("%d\\n", r);      // [4]
    return 0;               // [5]
}`;

    function scriptRecursion() {
      const addrRMain = toHex(STACK_TOP - 0x20);

      const mkFrame = (name, n, base) => ({
        name,
        locals: [ { name: name === "main" ? "r" : "n", type: "int", addr: toHex(base), size: 4, value: n } ],
      });

      const f3 = mkFrame("fact", 3, STACK_TOP - 0x24);
      const f2 = mkFrame("fact", 2, STACK_TOP - 0x28);
      const f1 = mkFrame("fact", 1, STACK_TOP - 0x2C);

      const steps = [
        { lines: [9],  desc: "main শুরু", stack: [ { name: "main", locals: [] } ], heap: [], stdout: "" },
        { lines: [10], desc: "int r = fact(3); → fact(3) কল", stack: [ { name: "main", locals: [] }, f3 ], heap: [], stdout: "" },
        { lines: [3],  desc: "fact(3): n<=1 নয় → fact(2)", stack: [ { name: "main", locals: [] }, f3, f2 ], heap: [], stdout: "" },
        { lines: [3],  desc: "fact(2): n<=1 নয় → fact(1)", stack: [ { name: "main", locals: [] }, f3, f2, f1 ], heap: [], stdout: "" },
        { lines: [2],  desc: "fact(1): n<=1 → 1 রিটার্ন", stack: [ { name: "main", locals: [] }, f3, f2 ], heap: [], stdout: "" },
        { lines: [4],  desc: "fact(2): 2 * 1 = 2 রিটার্ন", stack: [ { name: "main", locals: [] }, f3 ], heap: [], stdout: "" },
        { lines: [4],  desc: "fact(3): 3 * 2 = 6 রিটার্ন", stack: [ { name: "main", locals: [] } ], heap: [], stdout: "" },
        { lines: [10], desc: "main: r = 6", stack: [ { name: "main", locals: [ { name: "r", type: "int", addr: addrRMain, size: 4, value: 6 } ] } ], heap: [], stdout: "" },
        { lines: [11], desc: "printf → আউটপুটে 6", stack: [ { name: "main", locals: [ { name: "r", type: "int", addr: addrRMain, size: 4, value: 6 } ] } ], heap: [], stdout: "6\n" },
        { lines: [12], desc: "return 0; প্রোগ্রাম শেষ", stack: [ { name: "main", locals: [ { name: "r", type: "int", addr: addrRMain, size: 4, value: 6 } ] } ], heap: [], stdout: "6\n" },
      ];
      return steps;
    }

    // ---------- Scenario 3: Arrays & Strings ----------
    const codeArrays = `#include <stdio.h>
#include <string.h>

int main() {
    int arr[3] = {10, 20, 30};   // [1]
    arr[1] = 25;                  // [2]
    char str[6] = "Hello";        // [3]
    str[0] = 'M';                 // [4]
    printf("%d %s\\n", arr[1], str); // [5]
    return 0;                     // [6]
}`;

    function scriptArrays() {
      const addrArr = toHex(STACK_TOP - 0x30);
      const addrStr = toHex(STACK_TOP - 0x40);

      const steps = [
        { lines: [6], desc: "main শুরু, স্ট্যাক ফ্রেম তৈরি", stack: [ { name: "main", locals: [] } ], heap: [], stdout: "" },
        { lines: [7], desc: "int arr[3]={10,20,30}; → স্ট্যাকে 12 বাইট বরাদ্দ, মানগুলো সেট", stack: [
            { name: "main", locals: [
              { name: "arr", type: "int[3]", addr: addrArr, size: 12, value: [10,20,30] }
            ] }
          ], heap: [], stdout: "" },
        { lines: [8], desc: "arr[1] = 25; → arr এর দ্বিতীয় উপাদান পরিবর্তন", stack: [
            { name: "main", locals: [
              { name: "arr", type: "int[3]", addr: addrArr, size: 12, value: [10,25,30] }
            ] }
          ], heap: [], stdout: "" },
        { lines: [9], desc: 'char str[6] = "Hello"; → স্ট্যাক এ 6 বাইট বরাদ্দ, "Hello"', stack: [
            { name: "main", locals: [
              { name: "arr", type: "int[3]", addr: addrArr, size: 12, value: [10,25,30] },
              { name: "str", type: "char[6]", addr: addrStr, size: 6, value: ["H","e","l","l","o","\0"] }
            ] }
          ], heap: [], stdout: "" },
        { lines: [10], desc: "str[0] = 'M'; → 'Hello' → 'Mello'", stack: [
            { name: "main", locals: [
              { name: "arr", type: "int[3]", addr: addrArr, size: 12, value: [10,25,30] },
              { name: "str", type: "char[6]", addr: addrStr, size: 6, value: ["M","e","l","l","o","\0"] }
            ] }
          ], heap: [], stdout: "" },
        { lines: [11], desc: "printf → আউটপুটে arr[1] এবং str", stack: [
            { name: "main", locals: [
              { name: "arr", type: "int[3]", addr: addrArr, size: 12, value: [10,25,30] },
              { name: "str", type: "char[6]", addr: addrStr, size: 6, value: ["M","e","l","l","o","\0"] }
            ] }
          ], heap: [], stdout: "25 Mello\n" },
        { lines: [12], desc: "return 0; → প্রোগ্রাম শেষ", stack: [
            { name: "main", locals: [
              { name: "arr", type: "int[3]", addr: addrArr, size: 12, value: [10,25,30] },
              { name: "str", type: "char[6]", addr: addrStr, size: 6, value: ["M","e","l","l","o","\0"] }
            ] }
          ], heap: [], stdout: "25 Mello\n" },
      ];
      return steps;
    }

    // ---------- Scenario 4: Structs & Pointer-to-Struct ----------
    const codeStructs = `#include <stdio.h>
#include <stdlib.h>

struct Point {
    int x;
    int y;
};

int main() {
    struct Point p1 = {3, 4};         // [1]
    struct Point *ptr = &p1;          // [2]
    ptr->y = 10;                      // [3]
    printf("%d %d\\n", p1.x, p1.y);   // [4]
    return 0;                         // [5]
}`;

    function scriptStructs() {
      const addrP1 = toHex(STACK_TOP - 0x20);
      const addrPtr = toHex(STACK_TOP - 0x28);

      const steps = [
        { lines: [10], desc: "main শুরু, স্ট্যাক ফ্রেম তৈরি", stack: [ { name: "main", locals: [] } ], heap: [], stdout: "" },
        { lines: [11], desc: "struct Point p1={3,4}; → স্ট্যাক এ 8 বাইট, x=3, y=4", stack: [
            { name: "main", locals: [ { name: "p1", type: "struct Point", addr: addrP1, size: 8, value: { x:3, y:4 } } ] }
          ], heap: [], stdout: "" },
        { lines: [12], desc: "struct Point *ptr = &p1; → ptr এ p1 এর ঠিকানা", stack: [
            { name: "main", locals: [
              { name: "p1", type: "struct Point", addr: addrP1, size: 8, value: { x:3, y:4 } },
              { name: "ptr", type: "struct Point*", addr: addrPtr, size: 8, value: addrP1 }
            ] }
          ], heap: [], stdout: "" },
        { lines: [13], desc: "ptr->y = 10; → p1.y পরিবর্তন", stack: [
            { name: "main", locals: [
              { name: "p1", type: "struct Point", addr: addrP1, size: 8, value: { x:3, y:10 } },
              { name: "ptr", type: "struct Point*", addr: addrPtr, size: 8, value: addrP1 }
            ] }
          ], heap: [], stdout: "" },
        { lines: [14], desc: "printf → আউটপুটে 3 10", stack: [
            { name: "main", locals: [
              { name: "p1", type: "struct Point", addr: addrP1, size: 8, value: { x:3, y:10 } },
              { name: "ptr", type: "struct Point*", addr: addrPtr, size: 8, value: addrP1 }
            ] }
          ], heap: [], stdout: "3 10\n" },
        { lines: [15], desc: "return 0; → প্রোগ্রাম শেষ", stack: [
            { name: "main", locals: [
              { name: "p1", type: "struct Point", addr: addrP1, size: 8, value: { x:3, y:10 } },
              { name: "ptr", type: "struct Point*", addr: addrPtr, size: 8, value: addrP1 }
            ] }
          ], heap: [], stdout: "3 10\n" },
      ];
      return steps;
    }

    // ---------- Scenario 5: File I/O (Simulated) ----------
    const codeFiles = `#include <stdio.h>

int main() {
    FILE *f = fopen("data.txt","w"); // [1]
    if (!f) return 1;                // [2]
    fprintf(f, "12345");             // [3]
    fclose(f);                       // [4]
    return 0;                        // [5]
}`;

    function scriptFiles() {
      const addrF = toHex(STACK_TOP - 0x20);
      const steps = [
        { lines: [5], desc: "main শুরু, স্ট্যাক ফ্রেম তৈরি", stack: [ { name: "main", locals: [] } ], heap: [], stdout: "" },
        { lines: [6], desc: 'fopen → FILE* ফেরা, স্ট্যাকে f সংরক্ষণ', stack: [
            { name: "main", locals: [ { name: "f", type: "FILE*", addr: addrF, size: 8, value: "0xFILE1" } ] }
          ], heap: [], stdout: "" },
        { lines: [7], desc: "if (!f) → false (সফলভাবে খোলা)", stack: [
            { name: "main", locals: [ { name: "f", type: "FILE*", addr: addrF, size: 8, value: "0xFILE1" } ] }
          ], heap: [], stdout: "" },
        { lines: [8], desc: 'fprintf(f,"12345"); → ফাইল বাফারে লেখা (simulated)', stack: [
            { name: "main", locals: [ { name: "f", type: "FILE*", addr: addrF, size: 8, value: "0xFILE1" } ] }
          ], heap: [], stdout: "" },
        { lines: [9], desc: "fclose(f); → ফাইল বন্ধ", stack: [
            { name: "main", locals: [ { name: "f", type: "FILE*", addr: addrF, size: 8, value: "0xFILE1" } ] }
          ], heap: [], stdout: "" },
        { lines: [10], desc: "return 0; → প্রোগ্রাম শেষ", stack: [
            { name: "main", locals: [ { name: "f", type: "FILE*", addr: addrF, size: 8, value: "0xFILE1" } ] }
          ], heap: [], stdout: "" },
      ];
      return steps;
    }

    // ---------- NEW Scenario 6: Loops (for/while/do-while) ----------
    const codeLoops = `#include <stdio.h>

int main() {
    int sum = 0;                 // [1]
    int a[4] = {1, 2, 3, 4};     // [2]
    for (int i = 0; i < 4; i++) { // [3]
        sum += a[i];              // [4]
    }
    int n = 3;                    // [5]
    while (n > 0) {               // [6]
        sum += n;                 // [7]
        n--;                      // [8]
    }
    int x = 0;                    // [9]
    do {                          // [10]
        x++;                      // [11]
    } while (x < 2);              // [12]
    printf("%d %d\\n", sum, x);   // [13]
    return 0;                     // [14]
}`;

    function scriptLoops() {
      // Place locals at deterministic addresses
      const addrSum = toHex(STACK_TOP - 0x20);
      const addrArr = toHex(STACK_TOP - 0x30);
      const addrI   = toHex(STACK_TOP - 0x34);
      const addrN   = toHex(STACK_TOP - 0x38);
      const addrX   = toHex(STACK_TOP - 0x3C);

      // Helper to render array values
      const arrVal = (vals) => ({ name: "a", type: "int[4]", addr: addrArr, size: 16, value: vals });

      const steps = [];
      // start
      steps.push({ lines: [5], desc: "main শুরু → স্ট্যাক ফ্রেম তৈরি", stack: [ { name: "main", locals: [] } ], heap: [], stdout: "" });

      // sum init
      steps.push({ lines: [6], desc: "int sum=0; → sum বরাদ্দ", stack: [
        { name: "main", locals: [ { name: "sum", type: "int", addr: addrSum, size: 4, value: 0 } ] }
      ], heap: [], stdout: "" });

      // array init
      steps.push({ lines: [7], desc: "int a[4]={1,2,3,4}; → 16 বাইট বরাদ্দ", stack: [
        { name: "main", locals: [
          { name: "sum", type: "int", addr: addrSum, size: 4, value: 0 },
          arrVal([1,2,3,4]),
        ] }
      ], heap: [], stdout: "" });

      // for loop setup i=0
      steps.push({ lines: [8], desc: "for শুরু: i=0", stack: [
        { name: "main", locals: [
          { name: "sum", type: "int", addr: addrSum, size: 4, value: 0 },
          arrVal([1,2,3,4]),
          { name: "i", type: "int", addr: addrI, size: 4, value: 0 },
        ] }
      ], heap: [], stdout: "" });

      // i<4 true, body with i=0
      steps.push({ lines: [8], desc: "i<4 → true (i=0), লুপ বডি", stack: [
        { name: "main", locals: [
          { name: "sum", type: "int", addr: addrSum, size: 4, value: 0 },
          arrVal([1,2,3,4]),
          { name: "i", type: "int", addr: addrI, size: 4, value: 0 },
        ] }
      ], heap: [], stdout: "" });

      steps.push({ lines: [9], desc: "sum += a[0]; → sum=1", stack: [
        { name: "main", locals: [
          { name: "sum", type: "int", addr: addrSum, size: 4, value: 1 },
          arrVal([1,2,3,4]),
          { name: "i", type: "int", addr: addrI, size: 4, value: 0 },
        ] }
      ], heap: [], stdout: "" });

      // i++ to 1
      steps.push({ lines: [8], desc: "i++ → i=1", stack: [
        { name: "main", locals: [
          { name: "sum", type: "int", addr: addrSum, size: 4, value: 1 },
          arrVal([1,2,3,4]),
          { name: "i", type: "int", addr: addrI, size: 4, value: 1 },
        ] }
      ], heap: [], stdout: "" });

      // i=1 body
      steps.push({ lines: [8], desc: "i<4 → true (i=1)", stack: [
        { name: "main", locals: [
          { name: "sum", type: "int", addr: addrSum, size: 4, value: 1 },
          arrVal([1,2,3,4]),
          { name: "i", type: "int", addr: addrI, size: 4, value: 1 },
        ] }
      ], heap: [], stdout: "" });

      steps.push({ lines: [9], desc: "sum += a[1]; → sum=3", stack: [
        { name: "main", locals: [
          { name: "sum", type: "int", addr: addrSum, size: 4, value: 3 },
          arrVal([1,2,3,4]),
          { name: "i", type: "int", addr: addrI, size: 4, value: 1 },
        ] }
      ], heap: [], stdout: "" });

      // i=2
      steps.push({ lines: [8], desc: "i++ → i=2", stack: [
        { name: "main", locals: [
          { name: "sum", type: "int", addr: addrSum, size: 4, value: 3 },
          arrVal([1,2,3,4]),
          { name: "i", type: "int", addr: addrI, size: 4, value: 2 },
        ] }
      ], heap: [], stdout: "" });

      steps.push({ lines: [8], desc: "i<4 → true (i=2)", stack: [
        { name: "main", locals: [
          { name: "sum", type: "int", addr: addrSum, size: 4, value: 3 },
          arrVal([1,2,3,4]),
          { name: "i", type: "int", addr: addrI, size: 4, value: 2 },
        ] }
      ], heap: [], stdout: "" });

      steps.push({ lines: [9], desc: "sum += a[2]; → sum=6", stack: [
        { name: "main", locals: [
          { name: "sum", type: "int", addr: addrSum, size: 4, value: 6 },
          arrVal([1,2,3,4]),
          { name: "i", type: "int", addr: addrI, size: 4, value: 2 },
        ] }
      ], heap: [], stdout: "" });

      // i=3
      steps.push({ lines: [8], desc: "i++ → i=3", stack: [
        { name: "main", locals: [
          { name: "sum", type: "int", addr: addrSum, size: 4, value: 6 },
          arrVal([1,2,3,4]),
          { name: "i", type: "int", addr: addrI, size: 4, value: 3 },
        ] }
      ], heap: [], stdout: "" });

      steps.push({ lines: [8], desc: "i<4 → true (i=3)", stack: [
        { name: "main", locals: [
          { name: "sum", type: "int", addr: addrSum, size: 4, value: 6 },
          arrVal([1,2,3,4]),
          { name: "i", type: "int", addr: addrI, size: 4, value: 3 },
        ] }
      ], heap: [], stdout: "" });

      steps.push({ lines: [9], desc: "sum += a[3]; → sum=10", stack: [
        { name: "main", locals: [
          { name: "sum", type: "int", addr: addrSum, size: 4, value: 10 },
          arrVal([1,2,3,4]),
          { name: "i", type: "int", addr: addrI, size: 4, value: 3 },
        ] }
      ], heap: [], stdout: "" });

      // i=4 → exit for
      steps.push({ lines: [8], desc: "i++ → i=4; i<4 → false → for শেষ", stack: [
        { name: "main", locals: [
          { name: "sum", type: "int", addr: addrSum, size: 4, value: 10 },
          arrVal([1,2,3,4]),
          { name: "i", type: "int", addr: addrI, size: 4, value: 4 },
        ] }
      ], heap: [], stdout: "" });

      // while(n>0)
      steps.push({ lines: [10], desc: "int n=3; → while প্রস্তুতি", stack: [
        { name: "main", locals: [
          { name: "sum", type: "int", addr: addrSum, size: 4, value: 10 },
          arrVal([1,2,3,4]),
          { name: "i", type: "int", addr: addrI, size: 4, value: 4 },
          { name: "n", type: "int", addr: addrN, size: 4, value: 3 },
        ] }
      ], heap: [], stdout: "" });

      // while iter 1
      steps.push({ lines: [11], desc: "n>0 → true (n=3), বডি", stack: [
        { name: "main", locals: [
          { name: "sum", type: "int", addr: addrSum, size: 4, value: 10 },
          arrVal([1,2,3,4]),
          { name: "i", type: "int", addr: addrI, size: 4, value: 4 },
          { name: "n", type: "int", addr: addrN, size: 4, value: 3 },
        ] }
      ], heap: [], stdout: "" });

      steps.push({ lines: [12], desc: "sum += n; → sum=13", stack: [
        { name: "main", locals: [
          { name: "sum", type: "int", addr: addrSum, size: 4, value: 13 },
          arrVal([1,2,3,4]),
          { name: "i", type: "int", addr: addrI, size: 4, value: 4 },
          { name: "n", type: "int", addr: addrN, size: 4, value: 3 },
        ] }
      ], heap: [], stdout: "" });

      steps.push({ lines: [13], desc: "n--; → n=2", stack: [
        { name: "main", locals: [
          { name: "sum", type: "int", addr: addrSum, size: 4, value: 13 },
          arrVal([1,2,3,4]),
          { name: "i", type: "int", addr: addrI, size: 4, value: 4 },
          { name: "n", type: "int", addr: addrN, size: 4, value: 2 },
        ] }
      ], heap: [], stdout: "" });

      // while iter 2
      steps.push({ lines: [11], desc: "n>0 → true (n=2)", stack: [
        { name: "main", locals: [
          { name: "sum", type: "int", addr: addrSum, size: 4, value: 13 },
          arrVal([1,2,3,4]),
          { name: "i", type: "int", addr: addrI, size: 4, value: 4 },
          { name: "n", type: "int", addr: addrN, size: 4, value: 2 },
        ] }
      ], heap: [], stdout: "" });

      steps.push({ lines: [12], desc: "sum += n; → sum=15", stack: [
        { name: "main", locals: [
          { name: "sum", type: "int", addr: addrSum, size: 4, value: 15 },
          arrVal([1,2,3,4]),
          { name: "i", type: "int", addr: addrI, size: 4, value: 4 },
          { name: "n", type: "int", addr: addrN, size: 4, value: 2 },
        ] }
      ], heap: [], stdout: "" });

      steps.push({ lines: [13], desc: "n--; → n=1", stack: [
        { name: "main", locals: [
          { name: "sum", type: "int", addr: addrSum, size: 4, value: 15 },
          arrVal([1,2,3,4]),
          { name: "i", type: "int", addr: addrI, size: 4, value: 4 },
          { name: "n", type: "int", addr: addrN, size: 4, value: 1 },
        ] }
      ], heap: [], stdout: "" });

      // while iter 3
      steps.push({ lines: [11], desc: "n>0 → true (n=1)", stack: [
        { name: "main", locals: [
          { name: "sum", type: "int", addr: addrSum, size: 4, value: 15 },
          arrVal([1,2,3,4]),
          { name: "i", type: "int", addr: addrI, size: 4, value: 4 },
          { name: "n", type: "int", addr: addrN, size: 4, value: 1 },
        ] }
      ], heap: [], stdout: "" });

      steps.push({ lines: [12], desc: "sum += n; → sum=16", stack: [
        { name: "main", locals: [
          { name: "sum", type: "int", addr: addrSum, size: 4, value: 16 },
          arrVal([1,2,3,4]),
          { name: "i", type: "int", addr: addrI, size: 4, value: 4 },
          { name: "n", type: "int", addr: addrN, size: 4, value: 1 },
        ] }
      ], heap: [], stdout: "" });

      steps.push({ lines: [13], desc: "n--; → n=0; while শেষ", stack: [
        { name: "main", locals: [
          { name: "sum", type: "int", addr: addrSum, size: 4, value: 16 },
          arrVal([1,2,3,4]),
          { name: "i", type: "int", addr: addrI, size: 4, value: 4 },
          { name: "n", type: "int", addr: addrN, size: 4, value: 0 },
        ] }
      ], heap: [], stdout: "" });

      // do-while
      steps.push({ lines: [14], desc: "int x=0; → do-while প্রস্তুতি", stack: [
        { name: "main", locals: [
          { name: "sum", type: "int", addr: addrSum, size: 4, value: 16 },
          arrVal([1,2,3,4]),
          { name: "i", type: "int", addr: addrI, size: 4, value: 4 },
          { name: "n", type: "int", addr: addrN, size: 4, value: 0 },
          { name: "x", type: "int", addr: addrX, size: 4, value: 0 },
        ] }
      ], heap: [], stdout: "" });

      // do body 1
      steps.push({ lines: [15,16], desc: "do { x++; } → প্রথমে একবার চলবেই; x=1", stack: [
        { name: "main", locals: [
          { name: "sum", type: "int", addr: addrSum, size: 4, value: 16 },
          arrVal([1,2,3,4]),
          { name: "i", type: "int", addr: addrI, size: 4, value: 4 },
          { name: "n", type: "int", addr: addrN, size: 4, value: 0 },
          { name: "x", type: "int", addr: addrX, size: 4, value: 1 },
        ] }
      ], heap: [], stdout: "" });

      steps.push({ lines: [17], desc: "while(x<2) → true (x=1) → আবার বডি", stack: [
        { name: "main", locals: [
          { name: "sum", type: "int", addr: addrSum, size: 4, value: 16 },
          arrVal([1,2,3,4]),
          { name: "i", type: "int", addr: addrI, size: 4, value: 4 },
          { name: "n", type: "int", addr: addrN, size: 4, value: 0 },
          { name: "x", type: "int", addr: addrX, size: 4, value: 1 },
        ] }
      ], heap: [], stdout: "" });

      // do body 2
      steps.push({ lines: [16], desc: "x++; → x=2", stack: [
        { name: "main", locals: [
          { name: "sum", type: "int", addr: addrSum, size: 4, value: 16 },
          arrVal([1,2,3,4]),
          { name: "i", type: "int", addr: addrI, size: 4, value: 4 },
          { name: "n", type: "int", addr: addrN, size: 4, value: 0 },
          { name: "x", type: "int", addr: addrX, size: 4, value: 2 },
        ] }
      ], heap: [], stdout: "" });

      // condition false
      steps.push({ lines: [17], desc: "while(x<2) → false (x=2) → do-while শেষ", stack: [
        { name: "main", locals: [
          { name: "sum", type: "int", addr: addrSum, size: 4, value: 16 },
          arrVal([1,2,3,4]),
          { name: "i", type: "int", addr: addrI, size: 4, value: 4 },
          { name: "n", type: "int", addr: addrN, size: 4, value: 0 },
          { name: "x", type: "int", addr: addrX, size: 4, value: 2 },
        ] }
      ], heap: [], stdout: "" });

      // printf
      steps.push({ lines: [18], desc: "printf → sum=16, x=2 আউটপুট", stack: [
        { name: "main", locals: [
          { name: "sum", type: "int", addr: addrSum, size: 4, value: 16 },
          arrVal([1,2,3,4]),
          { name: "i", type: "int", addr: addrI, size: 4, value: 4 },
          { name: "n", type: "int", addr: addrN, size: 4, value: 0 },
          { name: "x", type: "int", addr: addrX, size: 4, value: 2 },
        ] }
      ], heap: [], stdout: "16 2\n" });

      steps.push({ lines: [19], desc: "return 0; → প্রোগ্রাম শেষ", stack: [
        { name: "main", locals: [
          { name: "sum", type: "int", addr: addrSum, size: 4, value: 16 },
          arrVal([1,2,3,4]),
          { name: "i", type: "int", addr: addrI, size: 4, value: 4 },
          { name: "n", type: "int", addr: addrN, size: 4, value: 0 },
          { name: "x", type: "int", addr: addrX, size: 4, value: 2 },
        ] }
      ], heap: [], stdout: "16 2\n" });

      return steps;
    }

    // ---------- UI panes ----------
    function CodePane({ code, highlighted }) {
      const lines = code.split("\n");
      return (
        <pre className="text-sm leading-6 whitespace-pre-wrap">
          {lines.map((ln, idx) => {
            const n = idx + 1;
            const isHi = highlighted.includes(n);
            return (
              <div key={idx} className={clsx("grid grid-cols-[48px_1fr] gap-3 px-2 rounded-md", isHi && "bg-emerald-900/30 ring-1 ring-emerald-500/50")}>
                <span className="text-zinc-500 select-none text-right pr-2">{n}</span>
                <code className="text-zinc-100">{ln}</code>
              </div>
            );
          })}
        </pre>
      );
    }

    function StackView({ frames }) {
      return (
        <div className="space-y-3">
          {(!frames || frames.length === 0) && <div className="text-zinc-400 text-sm">(empty)</div>}
          {frames && frames.map((f, i) => (
            <div key={i} className="rounded-xl border border-white/10 bg-zinc-800/60">
              <div className="px-3 py-2 text-amber-300 text-sm font-semibold flex items-center justify-between">
                <span>🔁 Stack Frame: {f.name}</span>
                <Pill>top</Pill>
              </div>
              <div className="px-3 pb-3">
                {(!f.locals || f.locals.length === 0) ? (
                  <div className="text-zinc-400 text-sm">No locals</div>
                ) : (
                  <table className="w-full text-sm">
                    <thead>
                      <tr className="text-zinc-400">
                        <th className="text-left font-medium py-1">Name</th>
                        <th className="text-left font-medium py-1">Type</th>
                        <th className="text-left font-medium py-1">Addr</th>
                        <th className="text-left font-medium py-1">Size</th>
                        <th className="text-left font-medium py-1">Value</th>
                      </tr>
                    </thead>
                    <tbody>
                      {f.locals.map((v, vi) => (
                        <tr key={vi} className="border-t border-white/5">
                          <td className="py-1">{v.name}</td>
                          <td className="py-1 text-zinc-300">{v.type}</td>
                          <td className="py-1 text-zinc-400">{v.addr}</td>
                          <td className="py-1 text-zinc-400">{v.size}</td>
                          <td className="py-1">{Array.isArray(v.value)
                              ? `[${v.value.join(", ")}]`
                              : (typeof v.value === 'object' && v.value !== null && !(v.value instanceof String))
                                ? JSON.stringify(v.value)
                                : (typeof v.value === 'string' ? v.value : String(v.value))}</td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                )}
              </div>
            </div>
          ))}
        </div>
      );
    }

    function HeapView({ blocks }) {
      return (
        <div className="space-y-3">
          {(!blocks || blocks.length === 0) && <div className="text-zinc-400 text-sm">(empty)</div>}
          {blocks && blocks.map((b, i) => (
            <div key={i} className={clsx("rounded-xl border bg-zinc-800/60", b.freed ? "border-red-500/40" : "border-emerald-500/30")}>
              <div className={clsx("px-3 py-2 text-sm font-semibold flex items-center justify-between", b.freed ? "text-red-300" : "text-emerald-300")}>
                <span>🧱 Heap Block @ {b.addr}</span>
                <Pill>{b.size} bytes</Pill>
              </div>
              <div className="px-3 pb-3">
                <div className="text-zinc-400 text-sm mb-2">{b.label || (b.freed ? "freed" : "allocated")}</div>
                {b.bytes && (
                  <div className="grid grid-cols-8 gap-1">
                    {b.bytes.map((byte, bi) => (
                      <div key={bi} className={clsx("text-xs px-2 py-1 rounded-md border", b.freed ? "border-red-500/30 bg-red-900/20" : "border-white/10 bg-zinc-900/60")}>
                        {byte === null ? "--" : String(byte)}
                      </div>
                    ))}
                  </div>
                )}
              </div>
            </div>
          ))}
        </div>
      );
    }

    function ConsoleView({ text }) {
      return (
        <div className="h-32 overflow-auto rounded-xl border border-white/10 bg-black/70 p-3 font-mono text-sm">
          {text || <span className="text-zinc-500">(no output)</span>}
        </div>
      );
    }

    // ---------- Main Component ----------
    function CMemoryVisualizer() {
      const [tab, setTab] = useState("pointers");
      const scenario = useMemo(() => {
        switch (tab) {
          case "pointers":
            return { name: "Pointers & malloc/free", code: codePointers, steps: scriptPointers() };
          case "recursion":
            return { name: "Functions & Recursion", code: codeRecursion, steps: scriptRecursion() };
          case "arrays":
            return { name: "Arrays & Strings", code: codeArrays, steps: scriptArrays() };
          case "structs":
            return { name: "Structs & Pointer-to-Struct", code: codeStructs, steps: scriptStructs() };
          case "files":
            return { name: "File I/O (Simulated)", code: codeFiles, steps: scriptFiles() };
          case "loops":
            return { name: "Loops: for / while / do-while", code: codeLoops, steps: scriptLoops() };
          default:
            return { name: "", code: "", steps: [] };
        }
      }, [tab]);

      const [i, setI] = useState(0);
      const step = scenario.steps[i] ?? scenario.steps[scenario.steps.length - 1];
      const max = scenario.steps.length - 1;
      const [auto, setAuto] = useState(false);
      const timer = useRef(null);

      useEffect(() => { setI(0); setAuto(false); }, [tab]);
      useEffect(() => {
        if (!auto) return;
        timer.current = setTimeout(() => setI(prev => Math.min(prev + 1, max)), 1100);
        return () => clearTimeout(timer.current);
      }, [auto, i, max]);

      return (
        <div className="min-h-screen bg-gradient-to-b from-zinc-950 to-black text-zinc-100 p-4 md:p-8">
          <div className="max-w-6xl mx-auto space-y-4">
            <header className="flex flex-col md:flex-row md:items-end md:justify-between gap-3">
              <div>
                <h1 className="text-2xl md:text-3xl font-bold"> Memory Execution Visualizer - React</h1>
                <p className="text-zinc-400 text-sm">বাংলা ব্যাখ্যাসহ স্ট্যাক, হিপ, পয়েন্টার, ফাংশন কল, লুপ, ও আউটপুট</p>
              </div>
              <div className="flex flex-wrap gap-2">
                {[
                  ["pointers", "Pointers"],
                  ["recursion", "Recursion"],
                  ["arrays", "Arrays/Strings"],
                  ["structs", "Structs"],
                  ["files", "File I/O"],
                  ["loops", "Loops"],
                ].map(([key, label]) => (
                  <button
                    key={key}
                    onClick={() => setTab(key)}
                    className={clsx(
                      "px-3 py-1.5 rounded-xl text-sm border",
                      tab === key ? "bg-emerald-600 border-emerald-500" : "bg-zinc-800 border-white/10 hover:bg-zinc-700"
                    )}
                  >{label}</button>
                ))}
              </div>
            </header>

            <div className="grid md:grid-cols-2 gap-4">
              <Card title={`${scenario.name} – Code`}>
                <CodePane code={scenario.code} highlighted={step.lines || []} />
              </Card>

              <div className="grid gap-4">
                <Card title="Current Step (Bangla explanation)">
                  <div className="text-sm leading-6">{step.desc}</div>
                </Card>
                <Card title="Console Output">
                  <ConsoleView text={step.stdout} />
                </Card>
              </div>
            </div>

            <div className="grid md:grid-cols-2 gap-4">
              <Card title="Stack (Call Frames)">
                <StackView frames={step.stack || []} />
              </Card>
              <Card title="Heap (Dynamic Memory)">
                <HeapView blocks={step.heap || []} />
              </Card>
            </div>

            <Card>
              <div className="flex flex-wrap items-center gap-2">
                <button onClick={() => setI(0)} className="px-3 py-1.5 rounded-xl bg-zinc-800 border border-white/10 hover:bg-zinc-700">⟲ Reset</button>
                <button onClick={() => setI(v => Math.max(0, v - 1))} className="px-3 py-1.5 rounded-xl bg-zinc-800 border border-white/10 hover:bg-zinc-700">◀ Prev</button>
                <button onClick={() => setI(v => Math.min(max, v + 1))} className="px-3 py-1.5 rounded-xl bg-emerald-600 hover:bg-emerald-500">Next ▶</button>
                <button onClick={() => setAuto(a => !a)} className={clsx("px-3 py-1.5 rounded-xl border", auto ? "bg-emerald-700 border-emerald-600" : "bg-zinc-800 border-white/10 hover:bg-zinc-700")}>{auto ? "■ Stop Auto" : "▶ Auto Play"}</button>
                <div className="text-sm text-zinc-400 ml-2">Step { (Math.min(i, max) + 1) } / { (max + 1) }</div>
              </div>
            </Card>

            <Card title="How to extend (Roadmap)">
              <ol className="list-decimal pl-5 space-y-1 text-sm text-zinc-300">
                <li><strong>Parser/Frontend:</strong> clang JSON trace বা WASM ইন্সট্রুমেন্টেশন থেকে স্টেপ জেনারেট।</li>
                <li><strong>Pointer arithmetic:</strong> arrays/strings এ & এবং * অপারেশন, pointer + k, k[p] ভিউ।</li>
                <li><strong>Structs:</strong> nested struct layout, padding/align, &obj, obj.field, p-&gt;field visualization।</li>
                <li><strong>Memory safety:</strong> use-after-free, double free, buffer overflow (স্যান্ডবক্স ডেমো) হাইলাইট।</li>
                <li><strong>Breakpoints & Watches:</strong> নির্দিষ্ট লাইন/ভ্যারিয়েবল পর্যবেক্ষণ, diff highlighting।</li>
                <li><strong>I/O model:</strong> stdin buffer, fread/fwrite simulation, file descriptor table।</li>
              </ol>
            </Card>

            <footer className="text-center text-xs text-zinc-500 py-4">
              Built for Md. Anisur Rahman – C Full Memory Visualizer (Prototype)
            </footer>
          </div>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById("root"));
    root.render(<CMemoryVisualizer />);
  </script>
</body>
</html>
